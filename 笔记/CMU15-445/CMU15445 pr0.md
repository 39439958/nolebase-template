## pr 0（6h）

![](https://github.com/39439958/nolebase-template/blob/main/picture/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-07%20161224.png)

pr0主要是在熟悉c++语法，这里记录一下要点。

1. 移动构造函数需要转移所有权的部分要注意使用`std::move()`：

```c++
  TrieNode(TrieNode &&other_trie_node) noexcept
      : key_char_(other_trie_node.key_char_),
        is_end_(other_trie_node.is_end_),
        children_(std::move(other_trie_node.children_)) {}
```

2. 这里的形参用了右值引用，child还是需要`std::move`表示可转移。

```c++
  std::unique_ptr<TrieNode> *InsertChildNode(char key_char, std::unique_ptr<TrieNode> &&child) {
      ...
    children_[key_char] = std::move(child);
      ...
  }
```

3. 当类有构造函数时，编译器不会自动生成默认的构造函数了。
4. 遍历时使用`std::unique_ptr<TrieNode> *cur = &root_;`是因为看到了前面的`GetChildNode`和`InsertChildNode`返回值都是`std::unique_ptr<TrieNode> *`，暂时不知道为啥不用普通的指针。
5. `mutex_.lock_shared()`是共享锁，多个线程能同时用，`mutex_.lock()`是互斥锁，同一时间只有一个线程能用，不能既要读锁又要写锁。
